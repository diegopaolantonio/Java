package com.proyectoPaolantonio.proyectoPaolantonio.controllers;

import com.proyectoPaolantonio.proyectoPaolantonio.entities.Cart;
import com.proyectoPaolantonio.proyectoPaolantonio.entities.Client;
import com.proyectoPaolantonio.proyectoPaolantonio.entities.Product;
import com.proyectoPaolantonio.proyectoPaolantonio.services.CartsService;
import com.proyectoPaolantonio.proyectoPaolantonio.services.ClientsService;
import com.proyectoPaolantonio.proyectoPaolantonio.services.ProductsService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("api/v1/carts")
@Tag(name = "Paths for carts", description = "CRUD of carts")
public class CartsController {

    @Autowired private CartsService service;
    @Autowired private ClientsService clientsService;
    @Autowired private ProductsService productsService;

    // Metodo para crear un cart, identificando el id del client y el del product en la ruta de la consulta
    @Operation(summary = "Create a new cart", description = "Create a new cart with the data sent in the 'path', in data 'id' is autogenerated, 'price' is taken from the 'product' and 'executed' is 'false' by default ")
    @ApiResponses( value = {
            @ApiResponse(responseCode = "201", description = "Cart created successfully", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Cart.class))),
            @ApiResponse(responseCode = "404", description = "Client or Product not found", content = @Content(mediaType = "", schema = @Schema())),
            @ApiResponse(responseCode = "409", description = "Conflict: Not enough stock available for the requested product", content = @Content(mediaType = "", schema = @Schema())),
            @ApiResponse(responseCode = "500", description = "Internal server error", content = @Content(mediaType = "", schema = @Schema()))
    })
    @PostMapping("/{clid}/{pid}/{amount}")
    public ResponseEntity<Cart> create(@PathVariable Long clid, @PathVariable Long pid, @PathVariable Integer amount) {
        try {
            Cart cart = new Cart();
            Integer newStock = 0;
            // Revisa si existe un client con el id especificado
            Optional<Client> foundClient = clientsService.readById(clid);
            if (!foundClient.isPresent()) {
                return ResponseEntity.notFound().build();
            }

            // Revisa si existe un product con el id especificado
            Optional<Product> foundProduct = productsService.readById(pid);
            if (!foundProduct.isPresent()) {
                return ResponseEntity.notFound().build();
            }

            // Carga el client especificado en el cart
            Client client = foundClient.get();
            cart.setClient(client);

            // Carga el product y el price del product especificado en el cart
            Product product = foundProduct.get();
            cart.setProduct(product);
            cart.setPrice(product.getPrice());

            // Carga el amount
            newStock = product.getStock() - amount;
            if(newStock >= 0 ) {
                cart.setAmount(amount);
                product.setStock(newStock);
                productsService.save(product);
            } else {
                return ResponseEntity.status(HttpStatus.CONFLICT).build();
            }

            // Carga el executed en false
            cart.setExecuted(false);

            return new ResponseEntity<>(service.save(cart), HttpStatus.CREATED);
        } catch (Exception e) {
            System.out.println(e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // Metodo para buscar todos los carts
    @Operation(summary = "Get all carts", description = "Retrives a list of all carts")
    @ApiResponses( value = {
            @ApiResponse(responseCode = "200", description = "Carts retrives successfully", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Cart.class))),
            @ApiResponse(responseCode = "500", description = "Internal server error", content = @Content(mediaType = "", schema = @Schema()))
    })
    @GetMapping
    public ResponseEntity<List<Cart>> readAll() {
        try {
            List<Cart> carts = service.readAll();
            return ResponseEntity.ok(carts);
        } catch (Exception e) {
            System.out.println(e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @Operation(summary = "Get carts of a client", description = "Retrives a list of carts of a client by its 'id'")
    @ApiResponses( value = {
            @ApiResponse(responseCode = "200", description = "Cart retrives successfully", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Cart.class))),
            @ApiResponse(responseCode = "404", description = "Client not found", content = @Content(mediaType = "", schema = @Schema())),
            @ApiResponse(responseCode = "500", description = "Internal server error", content = @Content(mediaType = "", schema = @Schema()))
    })
    @GetMapping("/{clid}")
    public ResponseEntity<List<Cart>> readByClientId(@PathVariable Long clid) {
        try {
            // Busca el cart especifico, si no existe devuelve "not found"
            Optional<Client> client = clientsService.readById(clid);
            if(!client.isPresent()) {
                return ResponseEntity.notFound().build();
            } else {
                return ResponseEntity.ok(client.get().getCarts());
            }
        } catch (Exception e) {
            System.out.println(e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // Metodo para buscar un cart especificado por el id enviado en la ruta
    @Operation(summary = "Get one cart", description = "Retrives one cart by its 'id'")
    @ApiResponses( value = {
            @ApiResponse(responseCode = "200", description = "Cart retrives successfully", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Cart.class))),
            @ApiResponse(responseCode = "404", description = "Cart not found", content = @Content(mediaType = "", schema = @Schema())),
            @ApiResponse(responseCode = "500", description = "Internal server error", content = @Content(mediaType = "", schema = @Schema()))
    })
    @GetMapping("/{cid}/cart")
    public ResponseEntity<Object> readById(@PathVariable Long cid) {
        try {
            // Busca el cart especifico, si no existe devuelve "not found"
            Optional<Cart> cart = service.readById(cid);
            if (cart.isPresent()) {
                return ResponseEntity.ok(cart.get());
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            System.out.println(e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // Metodo para actualizar un cart ya creado, identificado por el id especificado
    @Operation(summary = "Update one cart", description = "Update only amount to a cart by its 'id' if it was not executed, with the data sent in the 'body', 'id, client, product and executed' cannot be modified, 'amount' cannot be modified to null and 'price' it is automatically updated with the price of the product")
    @ApiResponses( value = {
            @ApiResponse(responseCode = "200", description = "Cart updated successfully", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Cart.class))),
            @ApiResponse(responseCode = "400", description = "Bad request: typing error", content = @Content(mediaType = "", schema = @Schema())),
            @ApiResponse(responseCode = "404", description = "Cart not found", content = @Content(mediaType = "", schema = @Schema())),
            @ApiResponse(responseCode = "409", description = "Conflict: Cart already executed o not enough stock available for the requested product", content = @Content(mediaType = "", schema = @Schema())),
            @ApiResponse(responseCode = "500", description = "Internal server error", content = @Content(mediaType = "", schema = @Schema()))
    })
    @PatchMapping("/{cid}")
    public ResponseEntity<Cart> update(@PathVariable Long cid, @RequestBody Cart cart) {
        try {
            System.out.println(cart);
            Integer amountDiference = 0;
            // Busca el cart por el id
            Optional<Cart> cartToUpdate = service.readById(cid);
            // Revisa si el cart existe, si no existe envia "not found"
            if (cartToUpdate.isPresent()) {
                // Pasa el cart encontrado a una variable tipo Cart
                Cart updatedCart = cartToUpdate.get();

                // Consulta si el cart ya fue ejecutado o si no hay amount para actualizar
                if(updatedCart.isExecuted() || cart.getAmount() == null || cart.getAmount() == updatedCart.getAmount()) {
                    return ResponseEntity.status(HttpStatus.CONFLICT).build();
                }

                // Revisa a la variacion del stock y devuelve o quita el stock del productos segun corresponda
                amountDiference = cart.getAmount() - updatedCart.getAmount();
                if (updatedCart.getProduct().getStock() >= amountDiference) {
                    Product product = updatedCart.getProduct();
                    product.setStock(product.getStock() - amountDiference);
                    productsService.save(product);
                } else {
                    return ResponseEntity.status(HttpStatus.CONFLICT).build();
                }

                // Actualiza el stock en el cart
                updatedCart.setAmount(cart.getAmount());

                // Actualiza el price con el price el product que esta en el cart
                updatedCart.setPrice(updatedCart.getProduct().getPrice());

                return ResponseEntity.ok(service.save(updatedCart));
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            System.out.println(e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // Metodo para eliminar un cart identificado por el id enviado en la ruta
    @Operation(summary = "Remove one cart", description = "Remove one cart by its 'id'")
    @ApiResponses( value = {
            @ApiResponse(responseCode = "200", description = "Cart deleted successfully", content = @Content(mediaType = "", schema = @Schema())),
            @ApiResponse(responseCode = "404", description = "Cart not found", content = @Content(mediaType = "", schema = @Schema())),
            @ApiResponse(responseCode = "500", description = "Internal server error", content = @Content(mediaType = "", schema = @Schema()))
    })
    @DeleteMapping("/{cid}")
    public ResponseEntity<Map<String, Boolean>> remove(@PathVariable Long cid) {
        try {
            // Busca si existe el cart con el id enviado, si existe lo elimina, si no devuelve "not found"
            Optional<Cart> cartToDelete = service.readById(cid);
            if (cartToDelete.isPresent()) {

                Product product = cartToDelete.get().getProduct();
                Integer cartToDeleteAmount = cartToDelete.get().getAmount();
                product.setStock(product.getStock() + cartToDeleteAmount);
                productsService.save(product);

                service.delete(cid);
                return ResponseEntity.ok().build();
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            System.out.println(e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

}
